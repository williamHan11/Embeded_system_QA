# 1. extern关键字的作用是什么？
- A. 声明外部链接
- B. 声明外部头文件引用
- C. 声明使用扩展C++语句
- D. 声明外部成员函数、成员数据
- 答案：D

# 2. 关于virtual void Draw()=0，下面说法正确的有几个？
1. 它是纯虚函数
2. 它在定义它的类中不能实现
3. 定义它的类不可实例化 
4. 如果一个类要继承一个ADT类，必须要实现其中的所有纯虚函数

- A. 1
- B. 2
- C. 3
- D. 4
- 答案：C

# 3. 对于类的常成员函数的描述正确的是？
- A. 常成员函数不修改类的数据成员
- B. 常成员函数可以对类的数据成员进行修改
- C. 常成员函数只能由常对象调用
- D. 常成员函数不能访问类的数据成员
- 答案：A

# 4. 无条件转移指令功能是将指令中的地址码送入？
- A. 栈寄存器
- B. PC
- C. 地址寄存器
- D. ALU
- 答案：B

# 5. C/C++的编译包括几个部分，分别是___，___和___。
- 答案：编译
- 汇编
- 链接

# 6. 在64位机器上分别使用-m32和-m64编译如下代码并在64位机器上执行，则输出为：___，____。
```
#include <stdio.h>
int main(int argc, char * argv[])
{
        void* number =  0;      printf("%d\n",sizeof(&number));
}
```

- 答案：4
- 8

# 7. 函数如下：
```
int function(x)  { 
    int flag = 0; 
    while(x)  { 
          x = x&(x-1); 
          flag ++; 
     } 
    return flag ; 
} 
```

问function(9561) =_____
- 答案：7

# 8. 语句 printf("%d",sizeof(Like)+sizeof(Mat));的执行结果是：_______
```
typedef union {
    Short i;
    int k[5];
    char c;
} Mat;
Typedef struct {
    int i;
    Mat j;
    double k;
}Like;
```

- 答案：52

# 9. 关键词______用于声明敏感变量（默认其他线程随时可以改变其值，因此每次运算都会读取新的值，避免误读缓存数据引发的错误）。
- volatile

# 10. 下列哪两条指令构成RAW型依赖关系？
- A. a = b + c;<br>a = c + d;
- B. a = b + c;<br>d = a + c;
- C. a = b + c;<br>d = b + c;
- D. a = b + c;<br>b = c + d;
- 答案：B

# 11. 对于乱序执行的处理器，下列哪个流水线阶段是乱序执行的？
- A. 取址/译码
- B. 寄存器重命名
- C. 指令执行
- D. 指令退休
- 答案：C

# 12. 关于NUMA架构，下列描述正确的是？
- A. 相对SMP对称多处理架构，NUMA架构的提出，是为了改善内存带宽的可扩展性。
- B. CPU访问NUMA多个远端节点内存的延迟都相同，且都大于访问本地节点的内存延迟
- C. 一颗CPU修改了共享的内存位置，需要广播给所有其他CPU。
- D. 计算密集型应用相对内存密集型应用可以从NUMA架构获得更多的性能提升。
- 答案：A

# 13. 关于this指针使用说法错误的是？
- A. 当创建一个对象后，this指针就指向该对象
- B. 成员函数拥有this指针
- C. 静态成员函数不拥有this指针
- D. 保证基类公有成员在子类中可以被访问
- 答案：D

# 14. 程序的局部变量存在于_____中，全局变量存在于____中，动态申请数据存在于____中，变量放在堆区与栈区的区别是______。
- 答案： 栈
- 静态区
- 堆
- 从申请方式，申请大小，申请效率简单比较：Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。Stack空间有限，Heap是很大的自由存储区。Stack申请效率高，Heap申请效率低。

# 15. 请写一个严谨的宏”MAX”，返回两个参数中较大的一个：______
- 答案：#define MAX(AB) (A>B?A:B)

# 16. 如何防止头文件被重复引用：______
- 答案：#ifndef/#define/#endif

# 17. 以下代码打印出的是：______
```
char *p = new char[10]; 
printf("%d\n", sizeof(p)); 
```

- 答案：4

# 18. 若一组记录的排序码为（32, 1, 52, 25, 88, 56），则利用快排的方法从小到大排序，以第一个记录为基准得到的一次划分结果为：_______
- 答案：25,1,32,52,88,56
