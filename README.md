# Embeded_system_QA
嵌入式系统面试题

## 1. STM启动方式？
1. 从Flash启动，将Flash地址0x08000000映射到0x00000000，这样启动以后就相当于从0x08000000开始的，这是我们最常用的模式。
2. 从SRAM启动，将SRAM地址0x20000000映射到0x00000000，这样启动以后就相当于从0x20000000开始的，用于调试。
3. 从系统存储器启动（system memory），将系统存储器地址0x1FFFF000映射到0x00000000，值得注意的是这个系统存储器里面存储的其实是STM32自带的Bootloader代码，它提供了可以通过UART1接口将用户的代码下载到Flash中的功能，然后将boot0置0，复位单片机，便可以Flash启动。（系统内存存储器我们没法烧写，因为它是一个只读的ROM，我们只能读取，但是可以通过从系统存储器启动，通过串口UART1烧录代码）

通过启动模式选择引脚来选择启动模式：

```
启动模式选择引脚   启动模式
BOOT1  BOOT2      
  X      0       主闪存存储器
  0      1       系统存储器
  1      1       内置SRAM
```

## 2. STM32上电到main函数之前做了什么事？
1. 初始化堆栈指针SP=_initial_sp
2. 初始化PC（通用寄存器指针）指针=Reset_Handler
3. SystemInit（配置系统时钟）
4. 调用C库函数_main初始化用户堆栈，从而最终调用main函数去到C的世界

## 3.FreeRTOS移植过程？
1. 下载源码
2. 拉取FreeRTOS\Source的所有.c文件=>内核源码
3. 拉取FreeRTOS\Source\portable{\MemMang,\RVDS\ARM_CM3}
4. 拉取FreeRTOS\Source\include=>头文件
5. 工程中C++配置目录
6. 修改FreeRTOSConfig.h文件，堆栈空间问题，时间节拍
7. 修改服务中断函数，stm32f10x_it.c，SysTick()
8. 注释PendSV_Handler()、SVC_Handler()函数

## 4.volatile关键字
1. volatile可以保证对特殊地址的稳定访问(防止因中断操作对地址中内容的修改，影响后续代码的正常运行)
2. 告诉编译器不要优化
3. 用处
    - 中断服务程序中修改的变量需要加volatile
    - 全局变量
    - 多任务环境下各任务间共享的标志应该加volatile

## 5.inline关键字
处理一些需要频繁操作的函数

1. inline是C++引入的关键字
2. inline只适合函数体内代码简单的函数使用
3. inline是一种“用于实现的关键字”
4. 内联是以代码膨胀（复制）为代价
5. 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大（不能有switch，while等）

## 6.信号量和互斥锁的区别？
信号量可以储存多个值，非负整数<br>
互斥锁只能存在0和1；

Mutex本质上说是一把锁，互斥功能，提供对资源的独占访问，所以Mutex主要的作用是用于互斥。

信号量，同步，是在多线程环境下使用的一种设施，它负责协调各个线程，以保证他们能够正确、合理地使用公共资源。

## 7.char型的数据，怎么将其第三位置零或者置一（类似：如何将ASCII字符大写字母改写成小写字母）？
使用按位与

## 8.如何让程序陷入无限循环？
- while(1)
- for(;;)
- do()while(1);
- state:  \n goto state;

## 9.int a = -20,unsigned int b = 6.a+b是否大于6？
- **有符号和无符号运算，强制转换为无符号**，所有a+b会变成(unsigned int)a+b
- (unsigned int)a就会相当于无符号最大值-20，那么是一个非常大的值，这个值加上6，那么肯定是大于6的
- 最后的值是2^32-20+6=4294967282，肯定大于6

## 10.已知有一个int型大小的内存及其地址，如何向该地址存入数据？
```
int main()
{
  int *p=(int *)0x3a47ba14;
  *p=10
  printf("%d,0x%x",*p,p);
  
  return 0;
}
```

## 11.进程通信的方式？共享内存是怎么做的？如果两个进程同时读写这块内存怎么办？
1. 进程通信方式：
    - 信号量
    - 消息队列
    - 管道
    - socket
    - 共享内存通信
2. 共享内存怎么做？
    - 共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如信号量。
      - 创建共享内存，指定key、size、mode
      - 将当前进程连接到共享内存
      - 把共享内存的地址读取出来，并强制转换为本地变量
      - 读写操作
